'use strict';

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('ws-shell');
var msgcodes = require('./msgcodes');
var events = require('events');
var _ = require('lodash');
var querystring = require('querystring');
var stream = require('readable-stream');
var through2 = require('through2');

// Load ws, if WebSocket isn't present on global/window
var WebSocket = global.WebSocket;
if (!WebSocket) {
  WebSocket = require('ws');
}

var MAX_MESSAGE_SIZE = 16 * 1024;

/** ShellClient */

var ShellClient = function (_events$EventEmitter) {
  (0, _inherits3.default)(ShellClient, _events$EventEmitter);

  function ShellClient(options) {
    (0, _classCallCheck3.default)(this, ShellClient);

    var _this = (0, _possibleConstructorReturn3.default)(this, (ShellClient.__proto__ || (0, _getPrototypeOf2.default)(ShellClient)).call(this));

    options = _.defaults({}, options, {
      tty: false,
      command: [],
      url: null
    });

    // Remember, if this is a tty
    _this.isTTY = options.tty;

    // Validate URL before we do anything
    if (!/^wss?:\/\/.+/.test(options.url)) {
      throw new Error('url must be ws:// or wss://, got: ' + options.url);
    }

    // Wrap commad in array, if it's a string
    if (typeof options.command === 'string') {
      options.command = [options.command];
    }

    // Validate command
    if (!(options.command instanceof Array)) {
      throw new Error('options.command must be an array');
    }
    if (!_.every(options.command, function (e) {
      return typeof e === 'string';
    })) {
      throw new Error('options.command must be an array of strings');
    }

    // Construct URL
    var url = options.url + '?' + querystring.stringify({
      tty: options.tty ? 'true' : 'false',
      command: options.command
    });

    // Construct websocket
    _this._ws = new WebSocket(url);
    _this._ws.binaryType = 'arraybuffer';

    // Handle websocket events
    _this._ws.addEventListener('open', function () {
      debug('websocket opened');
      _this.emit('open');
    });
    _this._ws.addEventListener('message', function (e) {
      return _this._handleMessage(e);
    });
    _this._ws.addEventListener('error', function (err) {
      debug('websocket error: %s', err);
      _this.emit('error', err);
    });

    // Ensure we only emit exit once
    _this._exitEmitted = false;
    _this._ws.addEventListener('close', function () {
      debug('websocket closed');
      if (!_this._exitEmitted) {
        _this.emit('exit', false);
        _this._exitEmitted = true;
      }
    });

    // Setup stdout stream
    _this.stdout = through2({ objectMode: false, allowHalfOpen: false });
    _this._stdoutOutstanding = 0;
    _this.stdout.on('drain', function () {
      if (_this._stdoutOutstanding > 0) {
        _this._sendAck(msgcodes.STREAM_STDOUT, _this._stdoutOutstanding);
        _this._stdoutOutstanding = 0;
      }
    });

    // Setup stderr stream
    _this.stderr = through2({ objectMode: false, allowHalfOpen: false });
    _this._stderrOutstanding = 0;
    _this.stderr.on('drain', function () {
      if (_this._stderrOutstanding > 0) {
        _this._sendAck(msgcodes.STREAM_STDERR, _this._stderrOutstanding);
        _this._stderrOutstanding = 0;
      }
    });

    // Setup stdin stream
    _this._pendingWrites = []; // {count, callback}
    _this.stdin = new stream.Writable({
      highWaterMark: MAX_MESSAGE_SIZE,
      decodeStrings: true, // docs are ambiguous here
      objectMode: false,
      write: _this._write.bind(_this),
      writev: function writev(chunks, callback) {
        var data = Buffer.concat(chunks.map(function (c) {
          return c.chunk;
        }));
        _this._write(data, null, callback);
      }
    });
    _this.stdin.on('finish', function () {
      var header = Buffer.from([msgcodes.MESSAGE_TYPE_DATA, msgcodes.STREAM_STDIN]);
      _this._ws.send(message);
      _this._pendingWrites.push({ count: 0, callback: function callback() {
          // TODO: Node streams doesn't support acknowleging that the stream was
          // successfully closed.
          debug('stream finished');
        }
      });
    });
    return _this;
  }

  (0, _createClass3.default)(ShellClient, [{
    key: '_handleMessage',
    value: function _handleMessage(e) {
      var m = Buffer.from(new Uint8Array(e.data));
      var c = m[0];
      m = m.slice(1);

      switch (c) {
        case msgcodes.MESSAGE_TYPE_DATA:
          return this._handleData(m[0], m.slice(1));

        case msgcodes.MESSAGE_TYPE_ACK:
          return this._handleAck(m[0], m.slice(1));

        case msgcodes.MESSAGE_TYPE_EXIT:
          var success = m[0] === 0;
          // Only emit exit once
          if (!this._exitEmitted) {
            this.emit('exit', success);
            this._exitEmitted = true;
          }
          return;

        default:
          debug('Unknown message code: %d', c);
      }
    }
  }, {
    key: '_handleData',
    value: function _handleData(streamId, m) {
      switch (streamId) {
        case msgcodes.STREAM_STDOUT:
          // close stdout, if payload is empty
          if (m.length === 0) {
            this.stdout.end();
            return;
          }
          // output m to stdout
          if (this.stdout.write(m)) {
            // If stream isn't blocked we send drain event immediately
            this._sendAck(msgcodes.STREAM_STDOUT, m.length);
            return;
          }
          // Wait for drain event before sending ack
          this._stdoutOutstanding += m.length;
          return;
        case msgcodes.STREAM_STDERR:
          // close stderr, if payload is empty
          if (m.length === 0) {
            this.stderr.end();
            return;
          }
          // output m to stderr
          if (this.stderr.write(m)) {
            // If stream isn't blocked we send drain event immediately
            this._sendAck(msgcodes.STREAM_STDERR, m.length);
            return;
          }
          // Wait for drain event before sending ack
          this._stderrOutstanding += m.length;
          return;
        default:
          debug('Unknown stream identifier: %d', streamId);
      }
    }
  }, {
    key: '_handleAck',
    value: function _handleAck(streamId, m) {
      if (streamId !== msgcodes.STREAM_STDIN) {
        return debug('Ack for unknown stream identifier: %d', streamId);
      }
      if (m.length !== 4) {
        return debug('Ack for stdin, but length was not 4');
      }
      var N = m.readUInt32BE(0);
      if (N === 0) {
        if (this._pendingWrites[0].count === 0) {
          this._pendingWrites.shift().callback();
        } else {
          this.emit('error', new Error('stdin closed before all writes was acknowledged'));
        }
      }
      // ack N from stdin
      while (this._pendingWrites.length > 0 && N > 0) {
        if (this._pendingWrites[0].count <= N) {
          N -= this._pendingWrites[0].count;
          this._pendingWrites.shift().callback();
        } else {
          this._pendingWrites[0].count -= N;
          N = 0;
        }
      }
      if (N > 0) {
        this.emit('error', new Error('Received acknowledgement for data not sent'));
      }
    }
  }, {
    key: '_write',
    value: function _write(data, encoding, callback) {
      while (data.length > MAX_MESSAGE_SIZE) {
        this._writeChunk(data.slice(0, MAX_MESSAGE_SIZE), null, function () {});
        data = data.slice(MAX_MESSAGE_SIZE);
      }
      this._writeChunk(data, null, callback);
    }
  }, {
    key: '_writeChunk',
    value: function _writeChunk(chunk, encoding, callback) {
      if (chunk.length === 0) {
        return callback();
      }
      var header = Buffer.from([msgcodes.MESSAGE_TYPE_DATA, msgcodes.STREAM_STDIN]);
      var message = Buffer.concat([header, chunk]);
      this._ws.send(message);
      this._pendingWrites.push({ count: chunk.length, callback: callback });
    }
  }, {
    key: '_sendAck',
    value: function _sendAck(streamId, N) {
      var m = Buffer.alloc(6);
      m[0] = msgcodes.MESSAGE_TYPE_ACK;
      m[1] = streamId;
      m.writeUInt32BE(N, 2);
      this._ws.send(m);
    }
  }, {
    key: 'resize',
    value: function resize(cols, rows) {
      var m = Buffer.alloc(5);
      m[0] = msgcodes.MESSAGE_TYPE_SIZE;
      m.writeUInt16BE(cols, 1);
      m.writeUInt16BE(rows, 3);
      this._ws.send(m);
    }
  }, {
    key: 'kill',
    value: function kill() {
      if (this._abortSent) {
        return;
      }
      this._abortSent = true;
      var m = Buffer.alloc(1);
      m[0] = msgcodes.MESSAGE_TYPE_ABORT;
      this._ws.send(m);
    }
  }, {
    key: 'close',
    value: function close() {
      try {
        this.kill();
      } catch (err) {
        debug('close() failed to call kill(), error: %s', err);
      }
      this._ws.close();
    }
  }]);
  return ShellClient;
}(events.EventEmitter);

// Export ShellClient


module.exports = ShellClient;
//# sourceMappingURL=client.js.map
