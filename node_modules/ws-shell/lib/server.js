'use strict';

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('ws-shell');
var msgcodes = require('./msgcodes');
var events = require('events');
var _ = require('lodash');
var querystring = require('querystring');
var stream = require('readable-stream');
var through2 = require('through2');

var MAX_OUTSTANDING = 64 * 1024;
var MAX_MESSAGE_SIZE = 16 * 1024;

var ShellHandler = function (_events$EventEmitter) {
  (0, _inherits3.default)(ShellHandler, _events$EventEmitter);

  function ShellHandler(websocket, process) {
    (0, _classCallCheck3.default)(this, ShellHandler);

    var _this = (0, _possibleConstructorReturn3.default)(this, (ShellHandler.__proto__ || (0, _getPrototypeOf2.default)(ShellHandler)).call(this));

    _this._process = process;
    _this._ws = websocket;
    _this._ws.on('error', function (err) {
      debug('websocket error: %s', err);
      _this.emit('error', err);
      _this._process.kill();
    });
    _this._exitSent = false;
    _this._process.on('error', function (err) {
      debug('process error: %s', err);
      _this.emit('error', err);
      _this._sendExit(false);
    });
    _this._process.on('exit', function (code) {
      debug('process exited, code: %d', code);
      _this._sendExit(code === 0);
    });
    _this._ws.on('message', function (m) {
      return _this._handleMessage(m);
    });

    // Stream stdout
    _this._stdoutOutstanding = 0;
    _this._process.stdout.on('data', function (data) {
      _this._write(msgcodes.STREAM_STDOUT, data);
      _this._stdoutOutstanding += data.length;
      if (_this._stdoutOutstanding >= MAX_OUTSTANDING) {
        _this._process.stdout.pause();
      }
    });
    _this._process.stdout.on('end', function () {
      _this._write(msgcodes.STREAM_STDOUT, null);
    });
    _this._process.stdout.resume();

    // Stream stderr
    _this._stderrOutstanding = 0;
    _this._process.stderr.on('data', function (data) {
      _this._write(msgcodes.STREAM_STDERR, data);
      _this._stderrOutstanding += data.length;
      if (_this._stderrOutstanding >= MAX_OUTSTANDING) {
        _this._process.stderr.pause();
      }
    });
    _this._process.stderr.on('end', function () {
      _this._write(msgcodes.STREAM_STDERR, null);
    });
    _this._process.stderr.resume();
    return _this;
  }

  (0, _createClass3.default)(ShellHandler, [{
    key: '_sendExit',
    value: function _sendExit(success) {
      if (this._exitSent) {
        return;
      }
      this._exitSent = true;
      this._ws.send(Buffer.from([msgcodes.MESSAGE_TYPE_EXIT, success ? 0 : 1]));
      this._ws.close();
    }
  }, {
    key: '_handleMessage',
    value: function _handleMessage(m) {
      var c = m[0];
      m = m.slice(1);
      switch (c) {
        case msgcodes.MESSAGE_TYPE_DATA:
          return this._handleData(m[0], m.slice(1));
        case msgcodes.MESSAGE_TYPE_ACK:
          return this._handleAck(m[0], m.slice(1));
        case msgcodes.MESSAGE_TYPE_SIZE:
          if (m.length === 4) {
            var cols = m.readUInt16BE(0);
            var rows = m.readUInt16BE(2);
            if (this._process.resize instanceof Function) {
              this._process.resize(cols, rows);
            } else {
              debug('process.resize(cols, rows) not defined, resize message ignored');
            }
          }
          return;
        case msgcodes.MESSAGE_TYPE_ABORT:
          return this._process.kill();
        default:
          debug('Unknown message code: %d', c);
      }
    }
  }, {
    key: '_handleData',
    value: function _handleData(streamId, m) {
      var _this2 = this;

      switch (streamId) {
        case msgcodes.STREAM_STDIN:
          if (m.length === 0) {
            this._process.stdin.end(function () {
              _this2._sendAck(0);
            });
            return;
          }
          this._process.stdin.write(m, function () {
            _this2._sendAck(m.length);
          });
          return;
        default:
          debug('Data for unhandled streamId: %d', streamId);
      }
    }
  }, {
    key: '_sendAck',
    value: function _sendAck(count) {
      var m = Buffer.alloc(6);
      m[0] = msgcodes.MESSAGE_TYPE_ACK;
      m[1] = msgcodes.STREAM_STDIN;
      m.writeUInt32BE(count, 2);
      this._ws.send(m);
    }
  }, {
    key: '_handleAck',
    value: function _handleAck(streamId, m) {
      if (m.length !== 4) {
        debug('Acknowledgement for streamId: %d not 4 bytes long', streamId);
        return;
      }
      var count = m.readUInt32BE(0);
      switch (streamId) {
        case msgcodes.STREAM_STDOUT:
          this._stdoutOutstanding -= count;
          if (this._stdoutOutstanding < MAX_OUTSTANDING) {
            this._process.stdout.resume();
          }
          break;
        case msgcodes.STREAM_STDERR:
          this._stderrOutstanding -= count;
          if (this._stderrOutstanding < MAX_OUTSTANDING) {
            this._process.stderr.resume();
          }
          break;
        default:
          debug('Acknowledgement for unknown streamId: %d', streamId);
      }
    }
  }, {
    key: '_write',
    value: function _write(streamId, data) {
      if (data === null) {
        // Empty payload signals end of stream
        data = Buffer.from([]);
      } else if (data.length === 0) {
        // Don't allow empty buffers as it signals end of stream
        return;
      }
      // Split into messages, if needed
      while (data.length > MAX_MESSAGE_SIZE) {
        this._writeChunk(streamId, data.slice(0, MAX_MESSAGE_SIZE));
        data = data.slice(MAX_MESSAGE_SIZE);
      }
      this._writeChunk(streamId, data);
    }
  }, {
    key: '_writeChunk',
    value: function _writeChunk(streamId, chunk) {
      var header = Buffer.from([msgcodes.MESSAGE_TYPE_DATA, streamId]);
      this._ws.send(Buffer.concat([header, chunk]));
    }
  }]);
  return ShellHandler;
}(events.EventEmitter);
//# sourceMappingURL=server.js.map
