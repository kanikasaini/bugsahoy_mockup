'use strict';

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var assert = require('assert');

/**
 * Determine whether a scope is valid.  Scopes must be strings of ASCII
 * characters 0x20-0x7e (printable characters, including space but no other
 * whitespace)
 */

var _validScope = /^[\x20-\x7e]*$/;
exports.validScope = function (scope) {
  return typeof scope == 'string' && _validScope.test(scope);
};

/**
 * Validate scope-sets for well-formedness.  See scopeMatch for the description
 * of a scope-set.
 */
exports.validateScopeSets = function (scopesets) {
  var msg = 'scopes must be an array of arrays of strings ' + '(disjunctive normal form)';
  assert(Array.isArray(scopesets), msg);
  assert(scopesets.every(function (conj) {
    return Array.isArray(conj) && conj.every(exports.validScope);
  }), msg);
};

function validateScopePatterns(scopePatterns) {
  assert(scopePatterns instanceof Array && scopePatterns.every(function (scope) {
    return typeof scope === 'string';
  }), 'scopes must be an array of strings');
}

/**
 * Auxiliary function to check if scopePatterns satisfies a scope-set
 *
 * Note that scopesets is an array of arrays of strings. For example:
 *  [['a', 'b'], ['c']]
 *
 * Is satisfied if either,
 *  i)  'a' and 'b' is satisfied, or
 *  ii) 'c' is satisfied.
 *
 * Also expressed as ('a' and 'b') or 'c'.
 */
exports.scopeMatch = function (scopePatterns, scopesets) {
  exports.validateScopeSets(scopesets);
  validateScopePatterns(scopePatterns);

  return scopesets.some(function (scopeset) {
    return scopeset.every(function (scope) {
      return scopePatterns.some(function (pattern) {
        if (scope === pattern) {
          return true;
        }
        if (/\*$/.test(pattern)) {
          return scope.indexOf(pattern.slice(0, -1)) === 0;
        }
        return false;
      });
    });
  });
};

/**
 * Finds scope intersections between two scope sets.
 */
exports.scopeIntersection = function (scopeset1, scopeset2) {
  return [].concat((0, _toConsumableArray3.default)(scopeset1.filter(function (s) {
    return exports.scopeMatch(scopeset2, [[s]]);
  })), (0, _toConsumableArray3.default)(scopeset2.filter(function (s) {
    return exports.scopeMatch(scopeset1, [[s]]);
  }))).filter(function (v, i, a) {
    return a.indexOf(v) === i;
  });
};
//# sourceMappingURL=scopes.js.map
