'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
var _ = require('lodash');
var assert = require('assert');
var debug = require('debug')('docker-exec-server');
var debugdata = require('debug')('docker-exec-server:data');
var Docker = require('dockerode-promise');
var EventEmitter = require('events').EventEmitter;
var fs = require('fs');
var msgcode = require('./messagecodes.js');
var through2 = require('through2').obj;
var url = require('url');
var ws = require('ws');

var MAX_OUTSTANDING_BYTES = 8 * 1024 * 1024;

var ExecSession = (function () {
  function ExecSession(options) {
    var _this = this;

    _classCallCheck(this, ExecSession);

    this.options = options;
    this.execOptions = {
      AttachStdout: true,
      AttachStderr: true,
      AttachStdin: true,
      Tty: options.tty,
      Detach: false,
      Cmd: options.command
    };
    this.attachOptions = {
      stream: true,
      stdin: true,
      stdout: true,
      stderr: true
    };
    this.container = options.container;
    this.server = options.server;
    this.socket = options.socket;
    this.closed = false;

    //must set this before this.execute() in case of premature close
    this.socket.on('close', function () {
      //should be how to ctrl+c ctrl+d, might be better way to kill
      debug('client close');
      //for now, it kills this session
      _this.close();
    });
  }

  _createClass(ExecSession, [{
    key: 'execute',
    value: function execute() {
      var execStream, header;
      return _regeneratorRuntime.async(function execute$(context$2$0) {
        var _this2 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.container.exec(this.execOptions));

          case 2:
            this.exec = context$2$0.sent;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.exec.start(this.attachOptions));

          case 5:
            this.execStream = context$2$0.sent;
            execStream = this.execStream;
            header = null;

            execStream.on('readable', function () {
              header = header || execStream.read(8);
              while (header !== null) {
                var type = header.readUInt8(0);
                var payload = execStream.read(header.readUInt32BE(4));
                if (payload === null) {
                  break;
                }
                if (!_this2.sendMessage(type, payload)) {
                  execStream.pause();
                  _this2.strbuf.once('drain', execStream.resume);
                }

                //try to set new header to continue reading
                header = execStream.read(8);
              }
            });
            //This stream is created solely for the purposes of pausing, because
            //data will only buffer up in streams using this.queue()
            // this.strbuf = through2();

            this.outstandingBytes = 0;
            this.socketBuffering = false;
            this.clientPause = false;

            this.strbuf = through2();
            this.strbuf.on('data', function (data) {
              _this2.outstandingBytes += data.length;
              debugdata(data);
              _this2.socket.send(data, { binary: true }, function () {
                _this2.outstandingBytes -= data.length;
              });
              if (_this2.outstandingBytes > MAX_OUTSTANDING_BYTES) {
                _this2.strbuf.pause();
                _this2.socketBuffering = true;
                debug('paused');
              } else {
                if (!_this2.clientPause && _this2.socketBuffering) {
                  _this2.strbuf.resume();
                  debug('resumed');
                }
                _this2.socketBuffering = false;
              }
            });

            execStream.resume();

            //handling input
            this.socket.on('message', function (message) {
              try {
                _this2.messageHandler(message);
              } catch (e) {
                debug('Error: %s %j, closing connection', e, e, e.stack);
                _this2.close();
              }
            });

            /*this.socket.on('close', () => {
              //TODO: this is VERY wrong, we should close stdin, that's all!
              //should be how to ctrl+c ctrl+d, might be better way to kill
              execStream.end('\x03\x04\r\nexit\r\n');
              debug('client close');
              //for now, it kills this session
              this.close();
            });*/

            //start recieving client output again
            execStream.on('drain', function () {
              _this2.sendCode(msgcode.resume);
              debug('resumed');
            });

            //When the process dies, the stream ends
            execStream.on('end', function () {
              _this2.execStreamEnd();
            });

            //send ready message to let client know it is ready
            this.sendCode(msgcode.resume);
            debug('server executed session');

          case 20:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'sendCode',
    value: function sendCode(code) {
      return this.strbuf.write(new Buffer([code]), { binary: true });
    }
  }, {
    key: 'sendMessage',
    value: function sendMessage(code, buffer) {
      return this.strbuf.write(Buffer.concat([new Buffer([code]), buffer]), { binary: true });
    }
  }, {
    key: 'messageHandler',
    value: function messageHandler(message) {
      switch (message[0]) {
        case msgcode.pause:
          this.clientPause = true;
          this.strbuf.pause();
          debug('paused');
          break;

        case msgcode.resume:
          if (!this.socketBuffering && this.clientPause) {
            this.strbuf.resume();
            debug('resumed');
          }
          this.clientPause = false;
          break;

        case msgcode.stdin:
          if (!this.execStream.write(message.slice(1), { binary: true })) {
            this.sendCode(msgcode.pause);
            debug('paused');
          }
          break;

        case msgcode.end:
          this.execStream.end();
          break;

        case msgcode.resize:
          if (this.options.tty) {
            this.exec.resize({
              h: message.readUInt16LE(1),
              w: message.readUInt16LE(3)
            });
          } else {
            this.sendMessage(msgcode.error, new Buffer('cannot resize, not a tty instance'));
          }
          break;

        default:
          debug('unknown msg code %s; message is %s', message[0], message.length);
          debug(message);
      }
    }
  }, {
    key: 'execStreamEnd',
    value: function execStreamEnd() {
      var info;
      return _regeneratorRuntime.async(function execStreamEnd$(context$2$0) {
        var _this3 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.exec.inspect());

          case 2:
            info = context$2$0.sent;

            debug('exit code: %s', info.ExitCode);
            if (!this.closed) {
              try {
                this.sendMessage(msgcode.stopped, new Buffer([info.ExitCode]));
                this.strbuf.end();
                this.strbuf.on('finish', function () {
                  _this3.close();
                });
              } catch (err) {
                debug('Failed to exec.inspect, err: %s, JSON: %j', err, err, err.stack);
                this.forceClose();
              }
            }

          case 5:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'forceClose',
    value: function forceClose() {
      if (!this.closed) {
        this.sendCode(msgcode.shutdown);
        this.close();
      }
    }
  }, {
    key: 'close',
    value: function close() {
      if (!this.closed) {
        this.closed = true;
        var index = this.server.sessions.indexOf(this);
        if (index >= 0) {
          this.server.sessions.splice(index, 1);
          debug('%s sessions remain', this.server.sessions.length);
          this.server.emit('session removed', this.server.sessions.length);
          try {
            this.execStream.end();
          } catch (err) {/*ignore*/}
          try {
            this.execStream.destroy();
          } catch (err) {/*ignore*/}
          try {
            this.socket.destroy();
          } catch (err) {/*ignore*/}
        }
      }
    }
  }]);

  return ExecSession;
})();

var DockerExecWebsocketServer = (function (_EventEmitter) {
  _inherits(DockerExecWebsocketServer, _EventEmitter);

  /* Creates Docker Exec instance on given container,
   * running the first message given as a command.
   *
   * Options:
   * {
   *    server:         // http.Server/https.Server to get connections from
   *    containerId:    // Name or id of docker container
   *    path:           // Path to accept websockets on
   *    dockerSocket:   // Path to the docker unix domain socket
   *    maxSessions:    // Maximum number of sessions allowed
   *    wrapperCommand: // Optional wrapper script which wraps the command query
   * }
   */

  function DockerExecWebsocketServer(options) {
    var _this4 = this;

    _classCallCheck(this, DockerExecWebsocketServer);

    // Initialize base class
    _get(Object.getPrototypeOf(DockerExecWebsocketServer.prototype), 'constructor', this).call(this);

    // Set default options
    this.options = options = _.defaults({}, options, {
      dockerSocket: '/var/run/docker.sock',
      maxSessions: 10,
      wrapperCommand: []
    });
    // Validate options
    assert(options.server, 'options.server is required');
    assert(options.containerId, 'options.containerId is required');
    assert(options.path, 'options.path is required');
    assert(options.wrapperCommand instanceof Array, 'options.wrapperCommand must be an array!');
    // Test that we have a docker socket
    assert(fs.statSync(this.options.dockerSocket).isSocket(), 'Are you sure that docker is running?');

    // Setup docker
    var docker = new Docker({ socketPath: options.dockerSocket });

    // Get container wrapper
    this.container = docker.getContainer(options.containerId);
    assert(this.container, 'could not get container from Docker');

    // Setup websocket server
    this.server = new ws.Server({
      server: options.server,
      path: options.path
    });
    debug('websocket server created for path: "%s"', options.path);

    // Track sessions
    this.sessions = [];

    this.server.on('connection', function (socket) {
      debug('connection received');
      _this4.onConnection(socket);
    });
  }

  _createClass(DockerExecWebsocketServer, [{
    key: 'onConnection',
    value: function onConnection(socket) {
      // Reject connection of we're at the session limit
      if (this.sessions.length >= this.options.maxSessions) {
        socket.send(Buffer.concat([new Buffer([msgcode.error]), new Buffer('Too many sessions active!')]));
        return socket.close();
      }

      // Find arguments from URL
      var args = url.parse(socket.upgradeReq.url, true).query;
      if (typeof args.command === 'string') {
        args.command = [args.command];
      }

      // Construct session
      var session = new ExecSession({
        container: this.container,
        socket: socket,
        command: this.options.wrapperCommand.concat(args.command),
        tty: /^true$/i.test(args.tty),
        server: this
      });

      this.sessions.push(session);
      session.execute()['catch'](function (err) {
        debug('Failed to execute session, err: %s, JSON: %j', err, err, err.stack);
      });

      debug('%s sessions created', this.sessions.length);
      this.emit('session', session);
      this.emit('session added', this.sessions.length);
    }
  }, {
    key: 'close',
    value: function close() {
      this.server.close();
      this.sessions.forEach(function (session) {
        session.forceClose();
      });
    }
  }]);

  return DockerExecWebsocketServer;
})(EventEmitter);

exports['default'] = DockerExecWebsocketServer;
module.exports = exports['default'];

//TODO: add error handling support here

// this.execStream = await new Promise(async (accept, reject) => {
//   var req = http.request({
//     socketPath: '/var/run/docker.sock', //replace with generic later
//     path: '/exec/' + this.exec.id + '/start?' + qs.stringify(this.attachOptions),
//     method: 'POST',
//     headers: {
//       'Content-Type': 'application/json',
//       'Connection': 'upgrade',
//       'Upgrade': 'tcp',
//     }
//   }, reject);
//   req.write(JSON.stringify({
//     Detach: false,
//     Tty: this.options.tty,
//   }));
//   req.end();
//   req.on('upgrade', accept);
//   req.on('error', reject);
//   req.setTimeout(10000, reject);
// });
// debug(this.execStream);
// this.execStream.write(new Buffer([30]));