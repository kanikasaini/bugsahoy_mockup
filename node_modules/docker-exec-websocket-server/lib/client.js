'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
var _ = require('lodash');
var assert = require('assert');
var debug = require('debug')('docker-exec-websocket-server:lib:client');
var debugdata = require('debug')('docker-exec-websocket-server:lib:rcv');
var EventEmitter = require('events').EventEmitter;
var msgcode = require('../lib/messagecodes.js');
var querystring = require('querystring');
var through2 = require('through2').obj;
var WS = require('ws');
var Promise = require('promise');

var BROWSER = typeof window === 'undefined';

var DockerExecWebsocketClient = (function (_EventEmitter) {
  _inherits(DockerExecWebsocketClient, _EventEmitter);

  function DockerExecWebsocketClient(options) {
    _classCallCheck(this, DockerExecWebsocketClient);

    _get(Object.getPrototypeOf(DockerExecWebsocketClient.prototype), 'constructor', this).call(this);
    this.options = _.defaults({}, options, {
      tty: true,
      command: 'sh',
      wsopts: {}
    });
  }

  /* Makes a client program with unbroken stdin, stdout, stderr streams
   * Is also an EventEmitter with 'exit' event
   *
   * Required options:
   * url parts (hostname port pathname)
   * or url
   * tty: whether or not we expect VT100 style output
   * command: array or string of command to be run in exec
   */

  _createClass(DockerExecWebsocketClient, [{
    key: 'execute',
    value: function execute() {
      var MAX_OUTSTANDING_BYTES;
      return _regeneratorRuntime.async(function execute$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this.url = this.options.url + '?' + querystring.stringify({
              tty: this.options.tty ? 'true' : 'false',
              command: this.options.command
            });
            debug(this.url);
            assert(/ws?s:\/\//.test(this.url), 'url required or malformed url input');

            //HACK: browser check
            if (BROWSER) {
              //means that this is probably node
              this.socket = new WS(this.url, this.options.wsopts);
            } else {
              //means this is probably a browser, which means we ignore options
              this.socket = new WebSocket(this.url);
            }

            this.socket.binaryType = 'arraybuffer';
            this.socket.addEventListener('open', function () {
              debug('socket opened');
              _this.emit('open');
            });

            this.stdin = through2(function (data, enc, cb) {
              _this.sendMessage(msgcode.stdin, data);
              cb();
            }, function (cb) {
              _this.sendCode(msgcode.end);
              cb();
            });

            MAX_OUTSTANDING_BYTES = 8 * 1024 * 1024;

            this.outstandingBytes = 0;

            //stream with pause buffering, everything passes thru here first
            this.strbuf = through2();
            this.strbuf.on('data', function (data) {
              _this.outstandingBytes += data.length;
              debug(_this.outstandingBytes);
              if (BROWSER) {
                _this.socket.send(data, { binary: true }, function () {
                  _this.outstandingBytes -= data.length;
                  debug(_this.outstandingBytes);
                });
              } else {
                _this.socket.send(data);
                _this.outstandingBytes -= data.length;
                debug(_this.outstandingBytes);
              }
              if (_this.outstandingBytes > MAX_OUTSTANDING_BYTES) {
                _this.strbuf.pause();
                _this.emit('paused');
                debug('paused');
              } else {
                _this.strbuf.resume();
                _this.emit('resumed');
                debug('resumed');
              }
            });
            //Starts out paused so that input isn't sent until server is ready
            this.strbuf.pause();

            this.stdout = through2();
            this.stderr = through2();
            this.stdout.draining = false;
            this.stderr.draining = false;

            this.stdout.on('drain', function () {
              _this.stdout.draining = false;
              if (!_this.stderr.draining) {
                _this.sendCode(msgcode.resume);
              }
            });

            this.stderr.on('drain', function () {
              _this.stderr.draining = false;
              if (!_this.stdout.draining) {
                _this.sendCode(msgcode.resume);
              }
            });

            this.socket.onmessage = function (messageEvent) {
              _this.messageHandler(messageEvent);
            };
            context$2$0.next = 21;
            return _regeneratorRuntime.awrap(new Promise(function (accept, reject) {
              _this.socket.addEventListener('error', reject);
              _this.socket.addEventListener('open', accept);
            }));

          case 21:
            this.socket.addEventListener('error', function (err) {
              return _this.emit('error', err);
            });
            debug('client connected');

          case 23:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'messageHandler',
    value: function messageHandler(messageEvent) {
      var message = new Buffer(new Uint8Array(messageEvent.data));
      debugdata(message);
      // the first byte is the message code
      switch (message[0]) {
        //pauses the client, causing strbuf to buffer
        case msgcode.pause:
          this.strbuf.pause();
          this.emit('paused');
          debug('paused');
          break;

        //resumes the client, flushing strbuf
        case msgcode.resume:
          this.strbuf.resume();
          this.emit('resumed');
          debug('resumed');
          break;

        case msgcode.stdout:
          if (!this.stdout.write(message.slice(1))) {
            this.sendCode(msgcode.pause);
            this.stdout.draining = true;
          }
          break;

        case msgcode.stderr:
          if (!this.stderr.write(message.slice(1))) {
            this.sendCode(msgcode.pause);
            this.stderr.draining = true;
          }
          break;

        //first byte contains exit code
        case msgcode.stopped:
          this.emit('exit', message.readInt8(1));
          this.close();
          break;

        case msgcode.shutdown:
          this.emit('shutdown');
          debug('server has shut down');
          this.close();
          break;

        case msgcode.error:
          this.emit('error', message.slice(1));
          break;

        default:
          debug('unknown msg code %s', message[0]);
      }
    }
  }, {
    key: 'resize',
    value: function resize(h, w) {
      if (!this.options.tty) {
        throw new Error('cannot resize, not a tty instance');
      } else {
        var buf = new Buffer(4);
        buf.writeUInt16LE(h, 0);
        buf.writeUInt16LE(w, 2);
        debug('resized to %sx%s', h, w);
        this.sendMessage(msgcode.resize, buf);
      }
    }
  }, {
    key: 'sendCode',
    value: function sendCode(code) {
      this.strbuf.write(new Buffer([code]));
    }
  }, {
    key: 'sendMessage',
    value: function sendMessage(code, data) {
      this.strbuf.write(Buffer.concat([new Buffer([code]), new Buffer(data)]));
    }
  }, {
    key: 'close',
    value: function close() {
      var _this2 = this;

      if (!this.strbuf.paused) {
        this.socket.close();
        this.stdin.end();
        this.stdout.end();
        this.stderr.end();
        this.strbuf.end();
      } else {
        this.strbuf.on('drain', function () {
          _this2.socket.close();
          _this2.stdin.end();
          _this2.stdout.end();
          _this2.stderr.end();
          _this2.strbuf.end();
        });
      }
    }
  }]);

  return DockerExecWebsocketClient;
})(EventEmitter);

exports['default'] = DockerExecWebsocketClient;
module.exports = exports['default'];